# Matching Engine Rules

## ðŸ”® Astrological Accuracy
- **Real Calculations**: Use actual astrological principles
- **Sign Compatibility**: Base on element and modality compatibility
- **East-West System**: Support both Western and Chinese astrology
- **Birth Chart Data**: Use sun, moon, and rising signs

## ðŸ“Š Compatibility Matrix
- **144 Combinations**: Support all Western-Chinese combinations
- **Scoring System**: Use 0-100 compatibility scores
- **Weighted Factors**: Consider multiple astrological factors
- **Real-time Updates**: Update compatibility as profiles change

## ðŸ§® Calculation Rules
- **Precision**: Use accurate date/time calculations
- **Timezone Handling**: Handle different timezones properly
- **Sign Assignment**: Use exact date ranges for sign assignment
- **Element Harmony**: Calculate element compatibility

## ðŸ“± Performance Rules
- **Fast Calculations**: Optimize for real-time matching
- **Caching**: Cache compatibility results
- **Batch Processing**: Process multiple matches efficiently
- **Memory Management**: Handle large datasets efficiently

## ðŸ”„ Data Flow
- **Input Validation**: Validate birth date and time
- **Sign Calculation**: Calculate signs automatically
- **Compatibility Scoring**: Generate compatibility scores
- **Ranking**: Rank matches by compatibility

## ðŸŽ¯ Matching Rules
- **Distance Filtering**: Filter by geographic proximity
- **Age Preferences**: Respect age preferences
- **Gender Preferences**: Respect orientation preferences
- **Cooldown Periods**: Implement pass cooldowns

## ðŸ“Š Analytics Rules
- **Match Tracking**: Track successful matches
- **User Behavior**: Analyze user preferences
- **Compatibility Trends**: Identify popular combinations
- **Privacy**: Protect user data and preferences

## ðŸ”§ Engine Architecture
- **Modular Design**: Separate calculation modules
- **Type Safety**: Use TypeScript for all calculations
- **Testing**: Test all calculation functions
- **Documentation**: Document all astrological formulas

## ðŸš€ Optimization Rules
- **Algorithm Efficiency**: Use efficient algorithms
- **Memory Usage**: Minimize memory footprint
- **CPU Usage**: Optimize for mobile devices
- **Battery Life**: Minimize battery drain

---
description: Guidelines for implementing GET API routes in Next.js
globs: 
alwaysApply: false
---
# GET API Route Guidelines

Guidelines for implementing GET API routes in Next.js App Router:

Basic Structure. Note how we auto generate the response type for use on the client:

```typescript
import { NextResponse } from "next/server";
import prisma from "@/utils/prisma";
import { withAuth } from "@/utils/middleware";

// Notice how we infer the response type. We don't need to manually type it out
export type GetExampleResponse = Awaited<ReturnType<typeof getData>>;

// The middleware does the error handling and authentication for us already
export const GET = withEmailAccount(async () => {
  const emailAccountId = request.auth.emailAccountId;
  
  const result = getData({ email });
  return NextResponse.json(result);
});

async function getData({ email }: { email: string }) {
  const items = await prisma.example.findMany({
    where: { email },
  });

  return { items };
}
```

See [data-fetching.mdc](mdc:.cursor/rules/astromatch-data-fetching.mdc) as to how this would be then used on the client.

Key Requirements:

   - Always wrap the handler with `withAuth` or `withEmailAccount` for consistent error handling and authentication.
   - `withAuth` gets the user. `withEmailAccount` gets the currently active email account. A user can have multiple email accounts under it.
   - We don't need try/catch as `withAuth` and `withEmailAccount` handles that.
   - Infer and export response type as in the example.
   - Use Prisma for database queries.
   - Return responses using `NextResponse.json()`

## AstroMatch Specific Examples

### Fetching User Profile
```typescript
export type GetUserProfileResponse = Awaited<ReturnType<typeof getUserProfile>>;

export const GET = withAuth(async (request) => {
  const { userId } = request.auth;
  const profile = await getUserProfile({ userId });
  return NextResponse.json(profile);
});

async function getUserProfile({ userId }: { userId: string }) {
  const profile = await prisma.user.findUnique({
    where: { id: userId },
    include: { preferences: true },
  });
  return { profile };
}
```

### Fetching Matches
```typescript
export type GetMatchesResponse = Awaited<ReturnType<typeof getMatches>>;

export const GET = withAuth(async (request) => {
  const { userId } = request.auth;
  const matches = await getMatches({ userId });
  return NextResponse.json(matches);
});

async function getMatches({ userId }: { userId: string }) {
  const matches = await prisma.match.findMany({
    where: { 
      OR: [
        { user1Id: userId },
        { user2Id: userId }
      ]
    },
    include: { 
      user1: { select: { name: true, photos: true } },
      user2: { select: { name: true, photos: true } }
    }
  });
  return { matches };
}
```

### Fetching Compatibility Data
```typescript
export type GetCompatibilityResponse = Awaited<ReturnType<typeof getCompatibility>>;

export const GET = withAuth(async (request) => {
  const { userId } = request.auth;
  const { searchParams } = new URL(request.url);
  const otherUserId = searchParams.get('otherUserId');
  
  if (!otherUserId) {
    return NextResponse.json({ error: 'otherUserId is required' }, { status: 400 });
  }
  
  const compatibility = await getCompatibility({ userId, otherUserId });
  return NextResponse.json(compatibility);
});

async function getCompatibility({ userId, otherUserId }: { userId: string; otherUserId: string }) {
  const user1 = await prisma.user.findUnique({ where: { id: userId } });
  const user2 = await prisma.user.findUnique({ where: { id: otherUserId } });
  
  if (!user1 || !user2) {
    throw new Error('User not found');
  }
  
  const compatibility = calculateCompatibility(user1, user2);
  return { compatibility };
}
```
